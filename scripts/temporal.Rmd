# Dual Mask - Temporal

```{r setup, message = FALSE, warning = FALSE, echo = FALSE, cache = FALSE}
library(knitr)

opts_chunk$set(cache = FALSE, cache.path = "temporal.cache/", 
               warning = FALSE, message = FALSE,
               tidy = TRUE, tidy.opts = list(width.cutoff = 100))

knit_hooks$set(htmlcap = function(before, options, envir) {
  if(!before) {
    paste('<p class="caption" align="left"><strong>Figure</strong>: ',options$htmlcap,"</p>",sep="")
  }
})

library(dplyr)
library(lme4)
library(reshape2)
library(AICcmodavg)
library(ggplot2)
library(grid)
library(gridExtra)
library(scales)
library(RColorBrewer)

source("./helper/report-stats.R")       # formatting lmer model output
source("./helper/within-subj-error.R")  # computing within-subject error
source("./helper/helper-funcs.R")       # import `%nin%` for filtering
```

```{r load-data, cache = FALSE, echo = 1:2, eval = 1:2}
df <- read.csv("./temporal/temporal-final.csv", stringsAsFactors = FALSE)
df <- filter(df, subj_id != "MWP502") # incomplete data
df <- filter(df, subj_id %nin% c("MWP524", "MWP518"))
```

# Descriptive statistics

```{r subj-means, echo = FALSE, fig.width = 6, fig.height = 6, fig.show = 'hold', fig.align = 'center', htmlcap = "Detect outlier subjects using by subject mean response times and error rates."}

subjs <- df %.% 
  group_by(subj_id) %.% 
  summarize(
    rt = mean(rt, na.rm = T),
    err = mean(is_error, na.rm = T)
  ) %.% 
  mutate(
    rank_rt = rank(rt, ties.method = "random"),
    rank_err = rank(err, ties.method = "random")
  )

ggplot(subjs, aes(x = rank_rt, y = rt, label = subj_id, color = subj_id)) +
  geom_point() +
  geom_text(hjust = 0, vjust = -0.5, angle = 45, size = 4) +
  coord_cartesian(xlim = c(0.5, 39), ylim = c(280, 850)) +
  scale_x_continuous("Subject (Ranked by RT)", breaks = c(1, seq(5, 35, by = 5), 37)) +
  scale_y_continuous("Average RT (ms)") +
  theme(legend.position = "none")

ggplot(subjs, aes(x = rank_err, y = err, label = subj_id, color = subj_id)) +
  geom_point() +
  geom_text(hjust = 0, vjust = -0.5, angle = 45, size = 4) +
  coord_cartesian(xlim = c(0.5, 39), ylim = c(0.0, .22)) +
  scale_x_continuous("Subject (Ranked by Errors)", breaks = c(1, seq(5, 35, by = 5), 37)) +
  scale_y_continuous("Error Rate", label = percent, breaks = seq(0,1,by=0.02)) +
  theme(legend.position = "none")
```

```{r remove-bad-subj}
df <- filter(df, subj_id %nin% c("MWP524", "MWP518")) # remove subjs with high error rates
```

# Overall response time and error rate by condition

```{r means, echo = FALSE}
df_agg <- df %.% 
  group_by(subj_id, cue_type, mask_type) %.%
  summarize(
    rt = mean(rt, na.rm = TRUE),
    err = mean(is_error, na.rm = TRUE)
  ) %.% ungroup()

df_agg %.% 
  group_by(cue_type, mask_type) %.%
  summarize(
    rt = mean(rt),
    err = mean(err)
  ) %.% 
  arrange(rev(mask_type), cue_type)
```

# Effect of mask **during** auditory cue on cueing effect

```{r during-on-cueing, echo = c(1, 4, 7)}
df_during <- filter(df, mask_type %in% c("nomask", "during"))
arrange(unique(df_during[,c("cue_type", "cue_l", "cue_q", "mask_type", "mask_c")]), mask_c, cue_type)

mod_during_rt <- lmerTest::lmer(rt ~ (cue_l + cue_q) * mask_c + (1|subj_id), data = df_during)
summarize_lmerTest(mod_during_rt, vars = c("cue_l", "cue_q", "mask_c", "cue_l:mask_c", "cue_q:mask_c"))
```

# Effect of mask **after** auditory cue on cueing effect

```{r after-on-cueing, echo = c(1, 4)}
df_after <- filter(df, mask_type %in% c("nomask", "after"))
arrange(unique(df_after[,c("cue_type", "cue_l", "cue_q", "mask_type", "mask_c")]), mask_c, cue_type)

mod_after_rt <- lmerTest::lmer(rt ~ (cue_l + cue_q) * mask_c + (1|subj_id), data = df_after)
summarize_lmerTest(mod_after_rt, vars = c("cue_l", "cue_q", "mask_c", "cue_l:mask_c", "cue_q:mask_c"))
```

# Plot

```{r temporal-plot, echo = FALSE, fig.width = 10, fig.align = 'center', fig.show = 'hold', htmlcap = "Results of Exp. 1B"}

inv_noise_val <- c("#7570b3", "#969696", "#1b9e77")
nointer_inter <- c("#92c5de", "#ca0020")
nointer_inter2 <- c(nointer_inter, nointer_inter[2])

# ------------------------------------------------------------------------------
# source("./figure/base_theme.R")
base_theme <- theme(
  text = element_text(family = "Helvetica", color = 'black', size = 8),
  line = element_line(color = 'black', size = 0.3),
  panel.background = element_blank(),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  axis.line = element_line(color = 'black'),
  axis.text = element_text(color = 'black', size = 8),
  axis.title = element_text(vjust = 0.3, size = 8),
  axis.ticks.x = element_line(color = 'black'),
  axis.ticks.y = element_line(color = 'black'),
  axis.ticks.length = unit(4, 'points'),
  legend.direction = "vertical",
  legend.background = element_blank(),
  legend.key = element_blank(),
  legend.text = element_text(size = 8),
  legend.title = element_text(size = 8, face = "plain"),
  legend.key.size = unit(10, units = "points"),
  plot.margin = unit(c(0.2,0,0,0), units = "in")
)

# ------------------------------------------------------------------------------

df_temporal <- read.csv("./temporal/temporal-final.csv", stringsAsFactors = FALSE)
df_temporal <- filter(df_temporal, subj_id %nin% c("MWP502", "MWP524", "MWP518"))

# ------------------------------------------------------------------------------
# RT means

mod <- lmer(rt ~ (cue_l + cue_q) * (mask_m + mask_r) + (1|subj_id), data = df_temporal)
x_preds <- unique(df_temporal[,c("cue_type", "cue_l", "cue_q", "mask_type", "mask_m", "mask_r")])
y_preds <- predictSE(mod, x_preds, type = "response", se.fit = TRUE)
rt_mean_se <- cbind(x_preds, y_preds) %.%
  mutate(
    cue_type = factor(cue_type, levels = c("invalid", "noise", "valid")),
    mask_type = factor(mask_type, levels = c("nomask", "during", "after")),
    mask_n = ifelse(mask_type == "nomask", 1, ifelse(mask_type == "during", 1.75, 2.2))
  ) %.%
  select(cue_type, mask_type, mask_n, rt = fit, mean_se = se.fit) %.%
  arrange(mask_type, cue_type)

rt_diff_se <- df_temporal %.%
  summarySEwithin(measurevar = "rt", na.rm = TRUE, idvar = "subj_id",
                  withinvars = c("mask_type", "cue_type")) %.%
  mutate(
    cue_type = factor(cue_type, levels = c("invalid", "noise", "valid")),
    mask_type = factor(mask_type, levels = c("nomask", "during", "after")),
    mask_n = ifelse(mask_type == "nomask", 1, ifelse(mask_type == "during", 1.75, 2.2))
  ) %.% 
  select(mask_type, mask_n, cue_type, diff_se = se) %.%
  arrange(mask_type, cue_type)

rt_means <- merge(rt_mean_se, rt_diff_se)

cue_type_dodge = position_dodge(width = 0.12)
temporal_means_plot <- ggplot(rt_means, aes(x = mask_n, y = rt, color = cue_type)) +
  geom_linerange(aes(group = cue_type, ymin = rt - mean_se, ymax = rt + mean_se), 
    position = cue_type_dodge, color = "gray", lty = 5, size = 0.2) +
  geom_errorbar(aes(ymin = rt - diff_se, ymax = rt + diff_se),
    position = cue_type_dodge, width = 0.1) +
  geom_point(position = cue_type_dodge,
    size = 1.8) +
  geom_line(aes(group = cue_type), position = cue_type_dodge, size = 0.4) +
  coord_cartesian(ylim = c(440, 560), xlim = c(0.6, 2.6)) +
  scale_y_continuous("") +
  scale_x_continuous("", breaks = c(1, 1.75, 2.2), 
    labels = c("No Interference", "During Cue", "After Cue")) +
  scale_color_manual("Auditory Cue", labels = c("Invalid", "Noise", "Valid"),
    values = inv_noise_val) +
  base_theme + theme(
    legend.position = c(0.8, 0.9)
    # axis.text.y = element_blank()
  )
temporal_means_plot

# ------------------------------------------------------------------------------
# Effect of mask on cueing effect in RTs

get_rt_estimates <- function(lmermod, confint_method = "Wald") {
  estimates <- summary(lmermod)$coefficients
  estimates <- as.data.frame(estimates)
  estimates$param <- row.names(estimates); row.names(estimates) <- NULL
  
  intervals <- confint(lmermod, method = confint_method)
  intervals <- as.data.frame(intervals)
  intervals$param <- row.names(intervals); row.names(intervals) <- NULL
  
  merge(estimates, intervals)
}

df_temporal_nomask <- filter(df_temporal, mask_type == "nomask")
mod_nomask_rt <- lmer(rt ~ cue_l + cue_q + (1|subj_id), data = df_temporal_nomask)
nomask_est <- get_rt_estimates(mod_nomask_rt) %.% mutate(mask_type = "nomask")

df_temporal_during <- filter(df_temporal, mask_type == "during")
mod_during_rt <- lmer(rt ~ cue_l + cue_q + (1|subj_id), data = df_temporal_during)
during_est <- get_rt_estimates(mod_during_rt) %.% mutate(mask_type = "during")

df_temporal_after <- filter(df_temporal, mask_type == "after")
mod_after_rt <- lmer(rt ~ cue_l + cue_q + (1|subj_id), data = df_temporal_after)
after_est <- get_rt_estimates(mod_after_rt) %.% mutate(mask_type = "after")

rt_estimates <- rbind(nomask_est, during_est, after_est) %.%
  mutate(mask_type = factor(mask_type, levels = c("nomask", "during", "after")),
         mask_n = ifelse(mask_type == "nomask", 1, ifelse(mask_type == "during", 1.75, 2.2))) %.%
  plyr::rename(c("Estimate" = "cue_effect", "2.5 %" = "lwr", "97.5 %" = "upr",
                 "Std. Error" = "se")) %.%
  filter(param == "cue_l") %.%
  select(cue_effect, se, lwr, upr, mask_type, mask_n)

temporal_cueing_plot <- ggplot(rt_estimates, aes(x = mask_n, y = cue_effect)) + 
  geom_bar(aes(fill = mask_type), stat = "identity", width = 0.3, color = "black",
    position = "identity", size = 0.4) +
  geom_errorbar(aes(ymin = cue_effect - se, ymax = cue_effect + se), size = 0.3,
    width = 0.08) + 
  coord_cartesian(ylim = c(0, 80), xlim = c(0.6, 2.6)) +
  scale_x_continuous("", breaks = c(1, 1.75, 2.2), 
    labels = c("No Interference", "During Cue", "After Cue")) +
  scale_y_continuous("", breaks = seq(0, 100, by=20)) +
  scale_fill_manual(values = nointer_inter2) +
  base_theme +
  theme(
    legend.position = "none"
    # axis.text.y = element_blank()
    # plot.margin = unit(c(-0.14, 0, 0, 0), units = "in")
  )
temporal_cueing_plot
```